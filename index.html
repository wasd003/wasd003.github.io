<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Primer C++Note" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/12/Primer%20C++Note/" class="article-date">
  <time datetime="2020-01-12T00:08:49.309Z" itemprop="datePublished">2020-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/12/Primer%20C++Note/">Primer C++Note</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <font size="5" face="黑体"/>

<center><h2>5.6 try语句块和异常处理</h2></center>

<p>###一.常用异常处理套路<br><strong>try-&gt;throw-&gt;catch</strong></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">	if(s1.isbn()!&#x3D;s2.isbn())</span><br><span class="line">	&#123;</span><br><span class="line">		throw runtime_error(&quot;isbn号必须相同&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;成功&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">catch(runtime_error err)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;err.what()&lt;&lt;endl;</span><br><span class="line">	return？;&#x2F;&#x2F;不用return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>.what()是标准异常类的成员函数，返回的是一个c风格字符串（const char*），里面的内容是初始化该对象时使用的字符串（本例就是isbn号必须相同）</p>
</blockquote>
<center><h2>6.5特殊语言特性</h2></center>  

<p>###一.默认参数函数<br>注意：一旦某个形参被赋予了默认值，其右侧所有的形参也必须被赋予默认值<br>设计：调整形参的顺序，将经常使用默认值的参数放在后面</p>
<p>###二.内联函数和constexpr函数<br><em>内联函数</em>:在函数返回值之前加上inline即可<br><em>constexpr函数</em>:对于那些在编译期就可以确定返回值的函数加上constexpr关键字可以使编译器优化。<br>注意：即便该函数并不返回字面值常量编译器也不会报错。</p>
<blockquote>
<p>多文件编写时内联函数和constexpr的定义通常写在.h文件中</p>
</blockquote>
<p>###三.assert断言<br>在程序执行到某处时，程序员相信此时一些值应该是多少，这时可以启用assert断言，如果这些值超出预期，就终止程序。assert(f),如果f是true，继续执行程序，如果f是false，终止程序，抛出异常  </p>
<blockquote>
<p>频繁的使用assert会造成很大的开销，可以在#include&lt;cassert&gt;之前#define NDEBUG禁止对assert的断言检测</p>
</blockquote>
<p>###四.常量成员函数<br>在函数的参数列表后加上const即可将普通成员函数变为常量成员函数<br>常量成员函数的好处：常量对象或者其引用或者指向它的指针不能调用普通的成员函数，但可以调用常量成员函数。将函数声明为常量成员函数可以提高程序的灵活性<br><strong>注意</strong>：<br><strong>（1）常量成员函数不能修改类的数据成员</strong><br><strong>（2）常量成员函数如果定义在类的外面，则参数列表后的const不可省略</strong><br>总结：如果成员函数不涉及修改类的数据成员的操作，则可以将其声明为常量成员函数</p>
<p>###五.默认拷贝<br>两个对象的默认拷贝（赋值）就是把对象中的每一个数据成员都赋值给赋值给另一个对象。如果对象中不包含指针，使用默认的拷贝就可以了</p>
<center><h2>7.2 访问控制与封装</h2></center>

<p>###一.友元的声明<br>友元的声明和普通意义上的声明是两回事，友元的声明只是为了取得访问权限，它不能代替普通意义上的函数或者类的声明。所以即使声明了友元函数，<br>为了使该函数在当前可见，仍需声明一遍<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct X</span><br><span class="line">&#123;</span><br><span class="line">	friend void f();</span><br><span class="line">	X()&#123;f();&#125;&#x2F;&#x2F;错误，f还未声明</span><br><span class="line">	void g();</span><br><span class="line">	void h();</span><br><span class="line">&#125;;</span><br><span class="line">void X::g()</span><br><span class="line">&#123;</span><br><span class="line">	f();&#x2F;&#x2F;错误，f还未声明</span><br><span class="line">&#125;</span><br><span class="line">void f();</span><br><span class="line">void X::h()</span><br><span class="line">&#123;</span><br><span class="line">	f();&#x2F;&#x2F;正确，f已经声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有的编译器并不需要再声明一遍，但是为了安全起见还是再声明一遍的好</p>
<center><h2>7.3 类的其他特性</h2></center>  

<p>###一.类中使用别名<br>在类中可以使用typedef来使用别名，这个typedef的作用域仅在类内。<br>注意：必须在使用别名之前声明typedef</p>
<p>###二.可变数据成员<br>将类中的数据成员设为可变的，则在const函数中也可以改变该变量的值<br>例如：mutable int a;</p>
<p>###三.类中不可以有该类类型的对象，但是可以有指向该类类型的指针，因为普通数据成员不允许是不完整的类型<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	test* ax;&#x2F;&#x2F;正确</span><br><span class="line">	test bx;&#x2F;&#x2F;错误，因为此时test还未定义完成，属于不完整的类型</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于这一点最简单的例子就是链表ListNode结构体  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class ListNode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	ListNode* next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<center><h2>7.5          构造函数再探</h2></center>  

<p>###一.常量&amp;&amp;引用只能用列表初始化<br>类中的数据成员如果是const或者引用或者某种为提供默认构造函数的类型，则它必须使用初始化列表进行初始化，不能够在构造函数的函数体中进行赋值<br>###二.初始化顺序<br>初始化的顺序取决于数据成员在类中的定义顺序而不取决于它们在初始化列表中的顺序。在写构造函数的时候尽量按照定义顺序去写初始化列表<br>###三.委托构造函数<br>在B构造函数的初始化列表调用A构造函数，则B构造函数称为委托构造函数<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	test(int a,int b,int c):a(a),b(b),c(c)&#123;&#125;</span><br><span class="line">	test() :test(0,0,0)&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">	int a;</span><br><span class="line">	int b;</span><br><span class="line">	int c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：这是c++11中的新特性，所以在vs2012中编译不通过<br>###四.隐式类型转换和explicit关键字<br><strong>一个函数如果需要类对象作为参数，并且这个类包含单一参数的构造函数（注意必须是单一参数），那么可以直接将这个参数作为函数的参数，编译器会自动调用类的单一参数构造函数临时创建一个类的对象。这个过程叫做隐式类型转换</strong>  </p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	test(int a) :a(a), b(0), c(0),d(&quot;&quot;) &#123;&#125;&#x2F;&#x2F;单一参数的构造函数</span><br><span class="line">private:</span><br><span class="line">	int a;</span><br><span class="line">	int b;	</span><br><span class="line">	int c;</span><br><span class="line">	string d;</span><br><span class="line">&#125;;</span><br><span class="line">void f(const test&amp;a)&#x2F;&#x2F;需要类对象作为参数的函数</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用成功&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a &#x3D; 3;</span><br><span class="line">	f(a);&#x2F;&#x2F;将int隐式转换为test类</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>如果要禁止这种类型转换，可以在单一参数构造函数前加上explicit关键字</em></strong><br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	explicit test(int a) :a(a), b(0), c(0),d(&quot;&quot;) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">	int a;</span><br><span class="line">	int b;	</span><br><span class="line">	int c;</span><br><span class="line">	string d;</span><br><span class="line">&#125;;</span><br><span class="line">void f(const test&amp;a)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用成功&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a &#x3D; 3;</span><br><span class="line">	f(a);&#x2F;&#x2F;错误，无法进行隐式类型转换</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###五.类的静态成员<br>注意：<br><strong>(1)静态成员函数如果在类外定义，不能加上static关键字</strong><br><strong>(2)静态数据成员不能在类的内部进行初始化，除非他是const int的</strong><br><strong>(3)静态数据成员可以作为默认实参也可以使用不完整类型</strong>  </p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	static int a;</span><br><span class="line">	void func(int x &#x3D; a);&#x2F;&#x2F;可以将static数据成员作为默认实参</span><br><span class="line">	static test b;&#x2F;&#x2F;正确，静态数据成员可以是不完整的类型</span><br><span class="line">	test c;&#x2F;&#x2F;错误，普通数据成员必须是完整的类型</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center><h2>8.1  io类</h2></center>  

<ol>
<li>io对象没有拷贝和赋值，这意味着函数的返回值以及参数只能是istream&amp;/ostream&amp;，并且不能是const的</li>
<li>输出的原理：程序需要输出若干句话，为了节省效率，不会输出若干次，而是会把这些话统一放在缓冲区然后一并输出。输出的过程，缓冲区会刷新。<br>以下是导致缓冲区刷新的若干原因：<br>（1）缓冲区满了<br>（2）程序正常结束<br>（3）使用endl:输出换行符然后刷新缓冲区；使用flush:刷新缓冲区；使用ends：输出空格然后刷新缓冲区<br>（4）设置unitbuf：则每次输出后都会刷新缓冲区（设置的方式：os&lt;&lt;unitbuf,如果要取消可以：os&lt;&lt;nounitbuf）<br>（5）一个输出流关联到另一个流，那么当读写另一个流的时候，输出流的缓冲区都会被刷新。例如：默认cin和cout是关联的，所以每当cin的时候cout的缓冲区都会被刷新  </li>
<li>警告：如果程序崩溃，缓冲区不会被刷新，那么需要输出的数据可能就停留在缓冲区而没有打印。<br>所以当调试一个已经崩溃的程序时，如果没有输出想要的数据，未必是代码没有执行也可能是已经执行了，但是程序崩溃后缓冲区没有被刷新，数据在缓冲区被挂起没有打印。</li>
</ol>
<center><h2> 8.2  文件输入输出</h2></center>  

<ol>
<li>头文件：#include&lt;fstream&gt;：继承自iostream<br>fstream中特有的操作：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（1）fstream file;</span><br><span class="line">（2）fstream file(s);</span><br><span class="line">（3）fstream file(s,mode);</span><br><span class="line">（4）file.open(s);</span><br><span class="line">（5）file.open(s,mode)&#x2F;&#x2F;2和4，3和5作用相同。只不过一个是初始化一个是后期与文件绑定</span><br><span class="line">（5）file.close();</span><br><span class="line">（6）file.is_open();</span><br></pre></td></tr></table></figure>
示例代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;首先定义一个流 input_stream</span><br><span class="line">    fstream input_stream;</span><br><span class="line">    &#x2F;&#x2F;然后用流的open函数打开一个文件，最好用绝对路径，注意为了避免路径被解释为转义字符，必须用双斜杠。最后的 ios::in 参数表示读取。</span><br><span class="line">    input_stream.open(&quot;D:\\temp.txt&quot;,ios::in);</span><br><span class="line">    int a;</span><br><span class="line">    &#x2F;&#x2F;下面这句表示从流内读取一个整数到变量a，可以类比 cin 的使用方法</span><br><span class="line">    input_stream &gt;&gt; a;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 这样也可以：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	fstream input_stream(&quot;D:\\test.txt&quot;, ios::in);</span><br><span class="line">	int a;</span><br><span class="line">	input_stream &gt;&gt; a;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以使用fstream类的对象作为iostream&amp;的实参。即：一个接受istream&amp;的函数可以用一个ifstream对象来调用  </li>
</ol>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><hr>
<p>重载运算符：  </p>
<ol>
<li>比较类运算符（==，!=，&gt;,&lt;等）返回的是bool值，参数是（const type&amp;rhs）,const函数  </li>
<li>运算类运算符(+,-,x,/等)返回的是拷贝，参数是（const type&amp;rhs），非const函数  创建一个临时对象，返回的是这个临时对象  </li>
<li>赋值类运算符（=，+=,-=,x=,/=）返回的是引用，参数是（const type&amp;rhs）,非const函数  </li>
<li>IO类 返回的是istream&amp;或者ostream&amp;,参数是I/Ostream&amp;和const type &amp;rhs，非const函数，必须写成友元函数，即添加friend关键字</li>
</ol>
<hr>
<p>模板类的编写方式  </p>
<ol>
<li>.cpp文件中，每写一个函数都要声明一遍template .h在class开头也要声明一遍</li>
<li>类的名称不再是name，而是name&lt;Type&gt;</li>
<li><strong>模板类的多文件编写</strong>：如果像普通的类一样多文件编写会出现链接错误<a href="https://www.cnblogs.com/lovemee/p/10706061.html" target="_blank" rel="noopener">原因</a>  </li>
</ol>
<p><strong>解决方法</strong>：模板类尽量不要多文件编写，把声明和定义写在一起编成一个.hpp文件（.hpp文件是将.h文件和.cpp文件混合编写的文件）。在主函数中include”name.hpp”即可</p>
<hr>
<p>关于cin：<br>cin字符串，遇见空格，TAB就结束了<br>cin字符，cin会自动忽略不可见字符，如果想读取不可见字符应该使用cin.get()</p>
<hr>
<p>数组作为参数传递：<br>在C/C++中，当数组作为函数的参数进行传递时，数组就自动退化为同类型的指针。因为如果把数组拷贝一份传过去，开销太大。<br>所以不论是(int *a),还是(int a[])，传递的实际上都是指针，即形参都会对实参产生影响。  </p>
<hr>
<center><h2>9.2 容器库概览</h2></center>  

<h3 id="一-迭代器"><a href="#一-迭代器" class="headerlink" title="一.迭代器"></a>一.迭代器</h3><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><p>begin() 指向第一个元素的迭代器<br>end() 指向最后一个元素后一个位置的迭代器<br>rbegin() 指向最后一个元素的迭代器<br>rend() 指向第一个元素前面一个位置的迭代器<br>上述四个迭代器还有对应的const_iterator版本 比如cbegin(),他返回的是const_iterator，不能修改容器内的元素，只能读。</p>
<blockquote>
<p>注意：auto it=vec.rbegin()导致的it类型是reverse_iterator,它的迭代器是反着的，所以倒序输出的正确写法是：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">for (auto it &#x3D; vec.rbegin(); it !&#x3D; vec.rend(); ++it)</span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line">#### 使用注意※※  </span><br><span class="line">1. **向容器插入&#x2F;删除元素可能会导致原来指向容器的迭代器失效，所以在对容器执行操作后记得要更新迭代器**。(如果是使用insert&#x2F;erase那么非常容易更新，这两个函数本身就返回更新的迭代器)  </span><br><span class="line">2. 不要保存.end()尾迭代器，因为它是最容易失效的迭代器。  </span><br><span class="line">3. 迭代器除了可以++,--还可以想普通指针一样+i</span><br><span class="line">### 二.swap和assign  </span><br><span class="line">#### swap  </span><br><span class="line">swap的速度很快，除了array外可以在o(1)的时间内完成，这是因为元素本身并未交换，只是交换了他们俩的数据结构  </span><br><span class="line">而array的swap是真正的交换两个容器中的数据，时间为O(max(m,n))    </span><br><span class="line">所以如果需要交换两个容器中的元素，大胆使用swap吧，这并不会带来额外的时间开销</span><br><span class="line">#### assign </span><br><span class="line">seq.assign(n,val)  将seq中的元素替换为n个值为val的元素  </span><br><span class="line">seq.assign(it1,it2) 将seq中的元素替换为[it1,it2)范围的元素  </span><br><span class="line"></span><br><span class="line">&lt;center&gt;&lt;h2&gt;9.3 顺序容器操作&lt;&#x2F;h2&gt;&lt;&#x2F;center&gt;  </span><br><span class="line"></span><br><span class="line">### 一.insert和erase  </span><br><span class="line">insert(it,val)  &#x2F;&#x2F;在it所指位置之前插入元素val，所有容器的insert操作都是前插  </span><br><span class="line">insert(it,n,val)  &#x2F;&#x2F;在it所指位置之前插入n个val  </span><br><span class="line">insert(it,tar1,tar2)  &#x2F;&#x2F;在it所指位置之前插入[tar1,tar2)范围的元素  </span><br><span class="line">&gt; 可以发现STL中常常同时重载这两种参数的函数:(1)(n,val)  (2) (it1,it2) </span><br><span class="line">  </span><br><span class="line">erase(it)  &#x2F;&#x2F;删除it所指元素  </span><br><span class="line">erase(it1,it2)  &#x2F;&#x2F;删除[it1,it2)范围的元素</span><br><span class="line">在C++11的新标准中，insert返回指向第一个新加入元素的迭代器  而erase返回被删除元素之后的元素的位置</span><br><span class="line">### 二.emplace  </span><br><span class="line">**emplace_back()与push_back()的区别**：正如emplace_back它的名字一样，它的插入操作是in place(原地的)  </span><br><span class="line">push_back(构造函数(arg1，arg2,...))会先调用构造函数创建一个临时对象，再调用拷贝构造函数创建该对象的拷贝，调用了两次构造函数   </span><br><span class="line">而emplace_back(arg1,arg2,...)会在原地调用构造函数创建出对象后直接push进容器内，只调用一次构造函数  </span><br><span class="line">### 三.front和back  </span><br><span class="line">**front()和back()返回的是容器中首尾元素的引用，这意味着修改vec.begin()&#x2F;end()也会导致容器中的首尾元素值发生变化！！**  </span><br><span class="line">### 四.随机访问  </span><br><span class="line">有两种随机访问的方式  </span><br><span class="line">下标访问 和 .at(index)访问  </span><br><span class="line"></span><br><span class="line">&lt;center&gt;&lt;h2&gt;9.5 额外的string操作&lt;&#x2F;h2&gt;&lt;&#x2F;center&gt;</span><br><span class="line"></span><br><span class="line">### 一.额外操作</span><br><span class="line">这些额外操作的参数基本上都是(pos,n)从pos位置开始，长度为n</span><br><span class="line">1. replace(pos,n,args)  &#x2F;&#x2F;将pos开始长度为n的字符串替换为args</span><br><span class="line">2. substr(pos,n)   &#x2F;&#x2F;提取pos开始长度为n的字串  </span><br><span class="line">3. erase(pos,n)   &#x2F;&#x2F;删除从pos开始长度为n的字串  </span><br><span class="line"></span><br><span class="line">### 二.匹配子串  </span><br><span class="line">s.find(arg)  &#x2F;&#x2F;返回匹配第一个位置的下标  查不到返回string::npos   </span><br><span class="line">s.rfind(args) &#x2F;&#x2F;返回匹配最后一个位置的下标</span><br><span class="line">s.find_first_of(args)  &#x2F;&#x2F;返回第一个s和args的交集字符的下标  </span><br><span class="line">s.find_first_not_of(args)  &#x2F;&#x2F;与上一个相反  </span><br><span class="line">s.find_last_of(args)  &#x2F;&#x2F;返回最后一个s和args的交集字符  </span><br><span class="line">s.find_last_not_of(args)  &#x2F;&#x2F;与上一个相反  </span><br><span class="line"></span><br><span class="line">### 三.数值转换  </span><br><span class="line">to_string  </span><br><span class="line">stoi  &#x2F;&#x2F;转换为int,下述类似  </span><br><span class="line">stol</span><br><span class="line">stoul</span><br><span class="line">stoll</span><br><span class="line">stoull</span><br><span class="line">stof</span><br><span class="line">stod</span><br><span class="line">stold  </span><br><span class="line"></span><br><span class="line">&lt;center&gt;&lt;h2&gt;9.6 容器适配器&lt;&#x2F;h2&gt;&lt;&#x2F;center&gt;  </span><br><span class="line"></span><br><span class="line">适配器是一种机制，能够使一种事物使用起来好像是另一种事物。分为容器适配器，函数适配器，迭代器适配器  </span><br><span class="line">**容器适配器有：stack,queue,priority_queue**    </span><br><span class="line">一个容器适配器接受一个已有的底层容器，实现新的接口，使之使用起来好像是另一个容器。    </span><br><span class="line">stack,queue都是基于deque实现的，priority_queue是基于vector实现的</span><br><span class="line"></span><br><span class="line">&lt;center&gt;&lt;h2&gt;10.3 定制操作&lt;&#x2F;h2&gt;&lt;&#x2F;center&gt;  </span><br><span class="line"></span><br><span class="line">stable_sort 稳定排序，维持相等元素之间的位置关系不变   </span><br><span class="line">###问题提出：对于某些特殊的情形，算法对函数的参数个数有规定，可是规定个数的参数个数无法满足函数的要求，怎么办?  </span><br><span class="line">###问题剖析：本质上就是如何改变一个函数的参数个数</span><br><span class="line">### 一.lamda表达式    </span><br><span class="line">**lamda表达式的解决方案：将多出来的参数放入捕获列表中** </span><br><span class="line">一般形式 **[捕获列表] (参数列表)-&gt;返回值 &#123;函数体&#125;;**  </span><br><span class="line">&gt; 注意函数体最后有分号   </span><br><span class="line"></span><br><span class="line">其中参数列表和返回值类型可以省略，捕获列表不可以  </span><br><span class="line">调用通过lamda表达式定义的函数的方法与调用普通函数的方法相同</span><br></pre></td></tr></table></figure>
<p>int main()<br>{<br>    int size = 0;<br>    string s=”12”;<br>    auto f = [size](const string&amp;s)-&gt;bool<br>    {<br>        return size &gt;= s.size();<br>    };<br>    cout&lt;&lt;f(s)&lt;&lt;endl;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">比如find_if()函数的第三个参数要求是一个一元谓词(单参函数),可是我们想写的是size&gt;&#x3D;s.size() ，有size和s两个变量，这时就可以使用lamda表达式，捕获size(就是上面的demo)  </span><br><span class="line">- 值捕获和引用捕获  </span><br><span class="line">上面的demo就是值捕获的例子，相当于传值  </span><br><span class="line">引用捕获比如[&amp;size]，相当于传引用  </span><br><span class="line">- 隐式捕获  </span><br><span class="line">可以不说明捕获了哪些变量而只说明通过那种方式捕获  </span><br><span class="line">值捕获[&#x3D;],引用捕获[&amp;]  </span><br><span class="line">- 在lamda中修改捕获变量的值  </span><br><span class="line">如果只通过值捕获是无法修改捕获变量的值的</span><br></pre></td></tr></table></figure>
<p>int main()<br>{<br>    int arg = 0;<br>    auto f = [arg] ()<br>    {<br>        return ++arg;<br>    };<br>    cout &lt;&lt; f()&lt;&lt;endl;<br>    cout &lt;&lt; arg;<br>}<br>//错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**如果想在lamda中修改又不对原变量产生影响可以使用mutable关键字**</span><br></pre></td></tr></table></figure>
<p>int main()<br>{<br>    int arg = 0;<br>    auto f = [arg] () mutable<br>    {<br>        return ++arg;<br>    };<br>    cout &lt;&lt; f()&lt;&lt;endl;<br>    cout &lt;&lt; arg;<br>}<br>//输出 1 0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**如果想在lamda中修改并且对原变量产生影响可以使用引用捕获**</span><br></pre></td></tr></table></figure>
<p>int main()<br>{<br>    int arg = 0;<br>    auto f = [&amp;arg] ()<br>    {<br>        return ++arg;<br>    };<br>    cout &lt;&lt; f()&lt;&lt;endl;<br>    cout &lt;&lt; arg;<br>}<br>//输出 1 1 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### 二.bind函数  </span><br><span class="line">**bind的解决方法：将多出来的参数绑定到函数上去**</span><br><span class="line">bind函数是一个函数适配器，它接受一个可调用对象生成一个新的可调用对象  </span><br><span class="line">基本语法：  </span><br><span class="line">auto newFunc&#x3D;bind(oldFunc,arg_list)  </span><br><span class="line">还是上面的例子</span><br></pre></td></tr></table></figure>
<p>bool check_size(const string&amp;s,int size)<br>{<br>    return size&gt;=s.size();<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">这时一个双参函数，将其改变为单参函数的方法是  </span><br><span class="line">auto new_check_size&#x3D;bind(check_size,_1,sz)  </span><br><span class="line">_1是一个占位符，占据const string&amp;的位置，将sz传递给了size  </span><br><span class="line">**直观理解**</span><br><span class="line">![](http:&#x2F;&#x2F;i2.tiimg.com&#x2F;699146&#x2F;6135cc8193d40f26.png)  </span><br><span class="line">&gt;注意：使用bind函数需要引入头文件&lt;functional&gt;  </span><br><span class="line">&gt;使用_n占位符需要引入命名空间 using namespace std::placeholders  </span><br><span class="line">- 使用bind重排参数顺序  </span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">bind(oldFund(_2,_1))  </span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">- 绑定引用  </span><br><span class="line">默认绑定的参数使用拷贝的方式，如果想使用引用的方式可以使用ref,如果想使用const 引用可以使用cref  </span><br><span class="line"></span><br><span class="line">&lt;center&gt;&lt;h2&gt;10.4 再谈迭代器&lt;&#x2F;h2&gt;&lt;&#x2F;center&gt;   </span><br><span class="line">### 一.反向迭代器在排序中的应用  </span><br><span class="line">sort(nums.rbegin(),rend())  &#x2F;&#x2F;倒序排序  </span><br><span class="line">### 二.反向迭代器在查找中的应用  </span><br><span class="line">auto it&#x3D;find(nums.rbegin(),nums.rend(),val);  </span><br><span class="line">查找nums中最后一个val的位置  </span><br><span class="line">&gt;注意：返回的是一个it是一个reverse_iterator，++&#x2F;--操作符是反的</span><br><span class="line">&lt;center&gt;&lt;h2&gt;10.5 泛型算法结构&lt;&#x2F;h2&gt;&lt;&#x2F;center&gt;  </span><br><span class="line"></span><br><span class="line">谓词函数：返回bool值的函数或者仿函数，几个参数就是几元谓词  </span><br><span class="line">### 算法命名规范  </span><br><span class="line">#### 使用谓词代替&#x3D;&#x3D;&#x2F;&lt;  </span><br><span class="line">比如sort(),可以重载&lt;，也可以自定义cmp函数  </span><br><span class="line">再如unique(),可以重载&#x3D;&#x3D;，也可以自定义cmp函数  </span><br><span class="line">#### _if版本  </span><br><span class="line">传递一个谓词，对返回值为真的元素进行操作  </span><br><span class="line">比如find_if(it1,it2,check),remove_if(it1,it2,check)  </span><br><span class="line">#### _copy版本  </span><br><span class="line">通常算法只在原先的容器上进行操作，如果想把数据输出到另一个容器，可以使用copy版本  </span><br><span class="line">比如reverse_copy(it1,it2,dest)  </span><br><span class="line">**dest为复制的起始位置**  </span><br><span class="line"></span><br><span class="line">&lt;center&gt;&lt;h2&gt;11.3 关联容器操作&lt;&#x2F;h2&gt;&lt;&#x2F;center&gt;  </span><br><span class="line"></span><br><span class="line">### 查找  </span><br><span class="line">find(k)  返回第一个值为k的迭代器  </span><br><span class="line">count(k)  返回值为k的元素个数  </span><br><span class="line">lower_bound(k)  返回第一个大于等于k的元素的迭代器  </span><br><span class="line">upper_bound(k)  返回第一个大于k的元素的迭代器  </span><br><span class="line">equal_range(k)  返回一个迭代器pair，pair的first指向第一个值为k的元素，pair的second指向最后一个值为k的元素的后一位，如果k不存在，两个都是end()  </span><br><span class="line">注意：**map是按照key来查找的，与value无关**  </span><br><span class="line"></span><br><span class="line">&lt;center&gt;&lt;h2&gt;11.4 无序容器&lt;&#x2F;h2&gt;&lt;&#x2F;center&gt;   </span><br><span class="line">注意：unordered_map的key以及unordered_set的值都不能是自定义类型，如果是自定义类型需要自己提供hash函数  </span><br><span class="line">map的key和set的值也不能是自定义类型，如果是自定义类型需要重载&lt;  </span><br><span class="line"></span><br><span class="line">&lt;center&gt;&lt;h2&gt;12.1 动态内存与智能指针&lt;&#x2F;h2&gt;&lt;&#x2F;center&gt;  </span><br><span class="line"></span><br><span class="line">###常用操作 </span><br><span class="line">shared_ptr&lt;Type&gt; sp;&#x2F;&#x2F;允许多个指针指向同一个对象   </span><br><span class="line">unique_ptr&lt;Type&gt; up;&#x2F;&#x2F;一次只能有一个指针指向一个对象  </span><br><span class="line">p &#x2F;&#x2F;如果p指向了一个对象返回true，如果p指向的是空对象返回false  </span><br><span class="line">p.use_count()&#x2F;&#x2F;shared_ptr独有的操作，返回同时与p共享同一个对象的指针个数  </span><br><span class="line">p.unique() &#x2F;&#x2F;return p.use_count()&#x3D;&#x3D;1  </span><br><span class="line">###make_shared  </span><br><span class="line">最安全的使用动态内存的方式就是使用make_shared函数，此函数**为一个对象动态分配内存并返回指向该对象的share_ptr指针**      </span><br><span class="line">使用方式：</span><br></pre></td></tr></table></figure>
<p>share_ptr<ListNode> ptr=make_shared<ListNode>(val);<br>与<br>auto ptr=new ListNode(val);<br>等价</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;使用智能指针代替传统指针简单来说就是使用make_shared替代new，使用&#x3D;nullptr替代delete  </span><br><span class="line">&gt;智能指针中有一个引用计数，如果某一块内存没有指针指向它，该块内存就会被释放  </span><br><span class="line">get函数的使用情况  </span><br><span class="line">get函数返回的是智能指针的内置指针(普通指针)，只在向某些不能使用智能指针，只能使用普通指针的函数传递参数时使用   </span><br><span class="line">注意：**使用了get返回的指针的代码不应该delete这个指针，因为这个指针是智能指针的内置指针，它的销毁应该自动完成而不是手动delete**  </span><br><span class="line">思考：**删除一个用智能指针写的单链表是不是只要把头节点置为nullptr，就删除了整条链表？**  </span><br><span class="line">###unique_ptr  </span><br><span class="line">unique_ptr的初始化：unique_ptr没有像make_shared一样的函数，只能使用new来初始化  </span><br><span class="line">例如：</span><br></pre></td></tr></table></figure>
<p>unique_ptr<int> sp(new int(42));  //正确<br>unique_ptr<int> sp=new int(42);  //错误<br>unique_ptr<int> sp1=sp;  //错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">####release  </span><br><span class="line">放弃unique_ptr对当前对象的控制权，并且返回该对象  </span><br><span class="line">####reset  </span><br><span class="line">unique_pre指向另一个对象，之前的对象由于无指针所指，被自动释放  </span><br><span class="line">示例</span><br></pre></td></tr></table></figure>
<p>p2.reset(p1.release)  //将p1的控制权转移给p2<br>unique_ptr<int> p3(p2.release())  //将p2的控制权转移给刚出生的p1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面这段代码输出为几?</span><br></pre></td></tr></table></figure>
<p>shared_ptr<int> func()<br>{<br>    auto p = make_shared<int>(10);<br>    return p;<br>}<br>int main()<br>{<br>    auto s = func();<br>    cout &lt;&lt; s.use_count() &lt;&lt; endl;<br>    return 0;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">答案：1  </span><br><span class="line">###  动态分配数组  </span><br><span class="line">可以对动态分配数组进行值初始化，方法是在中括号后面加一对空括号，表示初始化为0</span><br></pre></td></tr></table></figure>
<p>int *ptr=new int<a href="">n</a>;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也可以使用初始值列表</span><br></pre></td></tr></table></figure>
<p>int *ptr=new int [10]{1,2,3,4};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;上面代码最终的结果是：&#123;1，2，3，4，5，0，0，0，0，0&#125;  </span><br><span class="line"></span><br><span class="line">注意：**动态分配一个空数组是合法的**  </span><br><span class="line"></span><br><span class="line">### 动态分配数组与智能指针  </span><br><span class="line">可以使用unique_ptr动态分配一个数组</span><br></pre></td></tr></table></figure>
<p>unique_ptr&lt;int[]&gt; sp(new int [42])  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**该指针不支持点和箭头运算符，但是可以使用中括号访问数组中的元素**  </span><br><span class="line">### allocator类  </span><br><span class="line">普通的动态分配数组把内存分配和对象构造两个过程放在一起，使用allocator类可以把二者分开  </span><br><span class="line">即：**先分配原始内存，等需要的时候再构造对象**  </span><br><span class="line">API：  </span><br><span class="line">分配&#x2F;释放内存  </span><br><span class="line">构造&#x2F;析构对象</span><br></pre></td></tr></table></figure>
<p>allocator<T> alt;  //定义一个分配内存的分配器<br>auto vec=alt.allocate(n)  //vec指针指向一段长度为n的原始内存<br>alt.deallocate(vec,n)  //将vec指针指向的内存释放掉<br>alt.construct(p,args)  //在p指针所指向的原始内存构造一个对象<br>alt.destroy(p)  //摧毁p指针指向的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">拷贝与填充  </span><br><span class="line">见p430  </span><br><span class="line">### 补充内容</span><br><span class="line">####size_type&amp;&amp;size_t</span><br><span class="line">size_type类型：专门用来存放vector和string,size()返回值的变量类型  </span><br><span class="line">size_t类型：使用sizeof关键字得到的就是size_t类型  </span><br><span class="line">什么时候使用：**vector和string的下标变量应该使用size_type类型，普通数组的下标变量应该使用size_type类型**  </span><br><span class="line">####istringstream&amp;&amp;ostringstream&amp;&amp;stringstream  </span><br><span class="line">&gt;istringstream  </span><br><span class="line"></span><br><span class="line">将流中的内容放入字符串中</span><br><span class="line">用途：**将字符串按照不可见字符分割**</span><br></pre></td></tr></table></figure>
<p>istringstream flow(s) //使用s初始化字符串流<br>flow.str()//返回字符串流中储存的字符串<br>按照不可见字符将字符串分割的方法：<br>while(flow&gt;&gt;words)<br>{<br>    cout&lt;&lt;words&lt;&lt;endl;//每一个words是一小段字符串<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**注意flow&gt;&gt;words不是将words读取到flow中，而是把flow截取一部分放入words中**</span><br><span class="line"></span><br><span class="line">&gt;ostringstream  </span><br><span class="line"></span><br><span class="line">将普通字符串中的内容放入流中</span><br></pre></td></tr></table></figure>
<p>int main()<br>{<br>    ostringstream oss;<br>    istringstream iss;<br>    iss.str(“hi iss”);<br>    cout &lt;&lt; iss.str();<br>    string str;<br>    while (iss &gt;&gt; str)<br>        oss &lt;&lt; str &lt;&lt; endl;</p>
<pre><code>istringstream iss2(&quot;hi iss2&quot;);
while (iss2 &gt;&gt; str) {
    oss &lt;&lt; str &lt;&lt; endl;
}
cout &lt;&lt; oss.str();
return 0;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br></pre></td></tr></table></figure>
<p>hi<br>iss<br>hi<br>iss2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;stringstream  </span><br><span class="line"></span><br><span class="line">既有“&lt;&lt;”操作符也有“&gt;&gt;”操作符</span><br><span class="line">主要作用是**实现字符串和任意数据类型的转换**</span><br></pre></td></tr></table></figure>
<p>stringstream stream;<br>stream&lt;&lt;类型1；<br>stream&gt;&gt;类型2；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;center&gt;&lt;h2&gt;13.1 拷贝，赋值与销毁&lt;&#x2F;h2&gt;&lt;&#x2F;center&gt;  </span><br><span class="line"></span><br><span class="line">###拷贝构造函数&amp;&amp;拷贝赋值运算符  </span><br><span class="line">问：默认拷贝构造函数如何拷贝类中的数组？  </span><br><span class="line">答：**值拷贝，即拷贝出来的数组与数组值相同但地址不同，互不影响**  </span><br><span class="line">问：为什么拷贝构造函数的参数必须是引用类型？  </span><br><span class="line">答：**如果调用拷贝构造函数需要对象的拷贝，就会引起无限循环拷贝**  </span><br><span class="line">问：如果类中有引用，还会生成默认地拷贝构造函数以及拷贝赋值运算符吗，如果有const成员呢？  </span><br><span class="line">答：**不会，虽然可以给引用赋新值，但是赋新值并不能将引用指向当前的元素而是将与引用绑定的元素改为当前元素，虽然不会生成默认版本。而const成员干脆不能赋新值，所以也不会生成默认版本**  </span><br><span class="line">问：</span><br></pre></td></tr></table></figure>
<p>obj i=j;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">和</span><br></pre></td></tr></table></figure>
<p>obj i;<br>i=j;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一样吗？  </span><br><span class="line">答：不一样，第一个是直接初始化，调用拷贝构造函数，第二个是赋值，调用拷贝赋值运算符</span><br><span class="line">**&#x3D;default**  </span><br><span class="line">可以显式地指出让编译器生成默认的构造函数或赋值运算符  </span><br><span class="line">例如：</span><br></pre></td></tr></table></figure>
<p>node&amp; operator=(const node&amp;rhs) =default;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**&#x3D;delete**  </span><br><span class="line">可以显式地指出让编译器禁止默认的构造函数或赋值运算符  </span><br><span class="line">例如：</span><br></pre></td></tr></table></figure>
<p>node&amp; operator=(const node&amp;rhs) =delete;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**重载&#x3D;需要做到的三件事情**  </span><br><span class="line">&lt;1&gt;不仅要把右侧的内容拷贝到左侧，还要把左侧原有的资源释放  </span><br><span class="line">即：赋值运算符&#x3D;&#x3D;拷贝构造+析构  </span><br><span class="line">&lt;2&gt;处理自己给自己赋值的情况  </span><br><span class="line">&lt;3&gt;处理内存分配的情况  </span><br><span class="line">&gt;copy-and-swap技术  </span><br><span class="line"></span><br><span class="line">使用copy-and-swap技术可以很优雅简洁地完成上述三个要求    </span><br><span class="line">copy-and-swap的写法：</span><br></pre></td></tr></table></figure>
<p>myArray&amp; operator=(myArray rhs)//注意是值传递，不是传引用<br>    {<br>        Swap(*this, rhs);<br>        return *this;<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先：因为当*this与临时对象交换后，临时对象指向旧内存，当退出函数时临时对象析构自动释放旧内存  </span><br><span class="line">其次：对于自己给自己赋值的情况，相当于把自己换了一块内存空间存储(原来存在a处，生成临时对象在b处，交换后this存在b处，a处内存被释放)  </span><br><span class="line">最后：如果内存分配失败，那么在传参数时就会报错，根本不会进入函数体  </span><br><span class="line">整体写法：</span><br></pre></td></tr></table></figure>
<p>class myArray {<br>public:<br>    myArray(int size, int val) :size(size)<br>    {<br>        arr = size ? new int[size] : nullptr;<br>        for (int i = 0; i &lt; size; i++)<br>            arr[i] = val;<br>    }<br>    myArray(const myArray &amp;rhs):size(rhs.size)<br>    {<br>        arr = size ? new int[size] : nullptr;<br>        for (int i = 0; i &lt; size; i++)<br>            arr[i] = rhs.arr[i];<br>    }<br>    ~myArray(){<br>        delete[]arr;<br>    }<br>    void Swap(myArray &amp;lhs, myArray &amp;rhs)<br>    {<br>        std::swap(lhs.size, rhs.size);<br>        std::swap(lhs.arr, rhs.arr);<br>    }<br>    myArray&amp; operator=(myArray rhs)//使用copy-and-swap<br>    {<br>        Swap(*this, rhs);<br>        return *this;<br>    }<br>private:<br>    int size;<br>    int * arr;<br>};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 移动构造函数  </span><br><span class="line">左值：在内存中占有确定位置的对象  </span><br><span class="line">右值：在内存中不占有确定位置的对象  </span><br><span class="line">右值引用：为了与常规引用(左值引用)区分，使用&amp;&amp;来代表右值引用</span><br></pre></td></tr></table></figure>
<p>int i=42;<br>int &amp;r=i; //正确  r绑定到左值上<br>int &amp;&amp;rr=i; //错误，不能将一个右值引用绑定到左值上<br>int &amp;r2=i<em>42;//错误，不能将一个左值引用绑定到右值上<br>const int &amp;r3=i</em>42; //正确，可以将一个const的左值引用绑定到右值上<br>int &amp;&amp;rr2 =i*42;//正确，可以将一个右值引用绑定到一个右值上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">**移动构造函数的使用场景**：如果用a初始化b后，就将a析构。这种情况下如果拷贝一份很消耗时间，一种好的做法是将a的内存的管理权交给b。  </span><br><span class="line"></span><br><span class="line">移动构造函数的参数 ：Type (Type &amp;&amp;rhs);  </span><br><span class="line">调用的时候需要使用std::move强制转换为右值引用  </span><br><span class="line">写移动构造函数的方法：将rhs的内存用this接管，然后把rhs置为NULL</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure>
<p>class myArray {</p>
<p>public:<br>myArray(myArray &amp;&amp;rhs) noexcept :arr(rhs.arr)<br>{<br>    rhs.arr = NULL;<br>}<br>myArray()<br>{<br>    arr = new int[10];<br>    memset(arr, 0, sizeof arr);<br>}<br>~myArray()<br>{<br>    delete[]arr;<br>}<br>private:int *arr;<br>};<br>int main()<br>{<br>    myArray a;<br>    myArray b(std::move(a));<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;移动操作之后，以后源对象必须保持有效，可析构的状态，但是用户不能对其值做任何的假设  </span><br><span class="line"></span><br><span class="line">&gt;如果一个类定义了移动构造函数，那么其默认拷贝构造函数就被定义为删除的。因此，如果为一个类定义移动构造函数，那么也需要为其定义拷贝构造函数  </span><br><span class="line"></span><br><span class="line">**移动赋值运算符的写法**  </span><br><span class="line">同样使用copy-and-swap技术，只不过把名字换成了move-and-swap  </span><br><span class="line">只要定义了移动构造函数，那么赋值运算符就非常好写</span><br></pre></td></tr></table></figure>
<p>HasPtr&amp; operator=HasPtr(HasPtr rhs)<br>{<br>    swap(*this,rhs);<br>    return *this;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">hp&#x3D;hp1；&#x2F;&#x2F;这种情况调用拷贝赋值运算符  </span><br><span class="line">hp&#x3D;std::move(hp2)；&#x2F;&#x2F;这种情况调用移动赋值运算符  </span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line">**引用限定符**  </span><br><span class="line">如果在函数后面加上关键字&amp;&amp; 表示只有右值可以调用该函数  </span><br><span class="line">&amp;表示成员函数调用的对象需要是引用类型  </span><br><span class="line">&amp;&amp;表示成员函数调用对象需要是右值引用  </span><br><span class="line">![](https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;09&#x2F;nctxNl5YBbHodi2.png)  </span><br><span class="line"></span><br><span class="line">[function类模板](https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_35721743&#x2F;article&#x2F;details&#x2F;83217416)  </span><br><span class="line">**function对象可以指向任何可调用的对象，包括普通函数，类的static函数，类的普通成员函数，lamda表达式，仿函数甚至类的public数据成员**  </span><br><span class="line"></span><br><span class="line">&lt;center&gt;&lt;h2&gt;15.1 OOP：概述&lt;&#x2F;h2&gt;&lt;&#x2F;center&gt;  </span><br><span class="line"></span><br><span class="line">### 虚函数  </span><br><span class="line">#### 定义</span><br><span class="line">如果基类希望派生类各自定义适合他们的函数版本，应该把函数声明为虚函数。</span><br><span class="line">派生类在实现虚函数的时候可以加上virtual关键字，也可以不加。  </span><br><span class="line"></span><br><span class="line">#### 动态绑定  </span><br><span class="line">在使用基类的引用或者指针调用虚函数时会发生动态绑定  </span><br><span class="line">例如：</span><br></pre></td></tr></table></figure>
<p>class book<br>{<br>public:<br>    virtual void price() const<br>    {<br>        cout &lt;&lt; “调用父类”;<br>    }<br>};<br>class bulk :public book<br>{<br>public:<br>    virtual void price() const<br>    {<br>        cout &lt;&lt; “调用子类”;<br>    }<br>};<br>void func(const book&amp;rhs)//通过基类的引用调用虚函数<br>{<br>    rhs.price();<br>}<br>int main()<br>{<br>    book a;<br>    bulk b;<br>    func(a);<br>    func(b);<br>    return 0;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">虚函数与析构函数：**基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此**  </span><br><span class="line"></span><br><span class="line">&lt;center&gt;&lt;h2&gt;15.2 定义基类和派生类&lt;&#x2F;h2&gt;&lt;&#x2F;center&gt;  </span><br><span class="line"></span><br><span class="line">**一**.访问控制与继承  </span><br><span class="line">public|protected|private</span><br><span class="line">--|--|--</span><br><span class="line">|用户，派生类都可以访问|派生类可以访问用户不能|只有类中的成员函数以及友元可以访问|  </span><br><span class="line">**二.**</span><br><span class="line">派生类的构造函数：**初始化派生类的基类数据成员时应该使用基类的构造函数而不是直接初始化**  </span><br><span class="line">**三.**</span><br><span class="line">防止继承的发生：**C++11中定义了final关键字，如果不想让一个类被继承，可以在类的声明最后加上final** </span><br><span class="line">如：</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">class noDerived final&#123;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line">如果不想让一个函数被派生类中的函数覆盖，也可以将该函数声明为final的</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">**四.**</span><br><span class="line">注意：**从派生类到基类的类型转换只对指针或者引用类型有效**</span><br><span class="line">例如上例中：</span><br></pre></td></tr></table></figure>
<p>void func(const book&amp;rhs)//可以传入派生类实参<br>{<br>    rhs.price();<br>}<br>void func(const book rhs)//不可以传入派生类实参<br>{<br>    rhs.price();<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这也就是为什么可以使用派生类初始化基类或者给基类赋值，因为构造函数和拷贝控制函数的参数都是const引用，可以传入派生类的实参。  </span><br><span class="line">**使用copy-and-swap的坑**：如果是使用copy-and-swap技术重载的&#x3D;，那么在使用派生类实例给基类实例赋值的时候，因为无法调用拷贝赋值运算符函数，就会调用其他可以匹配的拷贝函数</span><br></pre></td></tr></table></figure>
<p>class myArray {<br>public:<br>    myArray(int size, int val) :size(size)//普通构造函数<br>    {<br>        arr = size ? new int[size] : nullptr;<br>        for (int i = 0; i &lt; size; i++)<br>            arr[i] = val;<br>    }<br>    myArray(const myArray &amp;rhs) :size(rhs.size)//拷贝构造函数<br>    {<br>        arr = size ? new int[size] : nullptr;<br>        for (int i = 0; i &lt; size; i++)<br>            arr[i] = rhs.arr[i];<br>    }<br>    ~myArray() {<br>        delete[]arr;<br>    }<br>    void Swap(myArray &amp;lhs, myArray &amp;rhs)<br>    {<br>        std::swap(lhs.size, rhs.size);<br>        std::swap(lhs.arr, rhs.arr);<br>    }<br>    myArray&amp; operator=(myArray rhs)//使用copy-and-swap实现的赋值运算符，注意到参数并不是&amp;<br>    {<br>        Swap(*this, rhs);<br>        return *this;<br>    }<br>private:<br>    int size;<br>    int * arr;<br>};<br>class derived:public myArray<br>{</p>
<p>public:derived(int size,int val,int more) :myArray(size,val),more(more) {}<br>private:int more;<br>};<br>int main()<br>{<br>    derived a(1, 10, 1);<br>    myArray b = a;//因为operator=函数无法匹配，所以会匹配到拷贝构造函数。可是拷贝构造函数是为初始化而写的，并没有销毁原内存的操作，造成内存泄露。<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">五.虚函数注意事项以及override</span><br><span class="line">**注意事项**:基类和派生类的虚函数应具有完全相同的参数和返回类型，如果他们具有不同的参数，这依然能够通过编译，但是编译器会认为这是两个不同的函数。 </span><br><span class="line">通常这种情况下都是因为错误导致的，会这种错误又很难排查，所以可以在派生类中将重新实现的虚函数加上override关键字，表明该函数需要覆盖一个函数。这样如果该函数并没有覆盖任何一个函数就会报错。  </span><br><span class="line">**tips：**一个好的习惯是，如果想在派生类中重写虚函数，为它加上override关键字。  </span><br><span class="line">六.虚函数与默认实参(**坑**)  </span><br><span class="line">**注意**:如果通过基类的引用或者指针调用函数，则使用基类定义的默认实参，即便是派生类实例调用的该函数。  </span><br><span class="line">**tips**：尽量保持基类和派生类的虚函数默认实参相同。  </span><br><span class="line">但是同样可以强行指定调用哪一个版本的虚函数。例如：</span><br></pre></td></tr></table></figure>
<p>auto price=derivedP-&gt;Base::func();//派生类实例强行调用其基类版本的func函数  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">六.纯虚函数与与抽象基类  </span><br><span class="line">纯虚函数：如果基类的虚函数并不需要有具体实现，可以将其&#x3D;0，表示这是一个纯虚函数。  </span><br><span class="line">抽象基类：如果一个类中含有纯虚函数，则该类是纯虚基类。**不能创建纯虚基类的实例**  </span><br><span class="line">纯虚函数示例：</span><br></pre></td></tr></table></figure>
<p>double price(std::size_t) const=0;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;center&gt;&lt;h2&gt;15.5 访问控制与继承&lt;&#x2F;h2&gt;&lt;&#x2F;center&gt;  </span><br><span class="line"></span><br><span class="line">#### 继承方式的作用</span><br><span class="line">不论是何种继承方式，它并不影响派生类的成员或者友元访问基类的public以及protected成员。他们影响的是派生类的使用者的访问权限。  </span><br><span class="line">继承方式说明符|public|protected|private</span><br><span class="line">-|-|-|-  </span><br><span class="line">从派生类的用户或者派生类的派生类的角度来看派生类的基类数据|访问权限不变，原先public还是public，原先protected还是protected|全部都变成protected|全部都变成private  </span><br><span class="line"></span><br><span class="line">#### 注意事项</span><br><span class="line">(1)派生类的用户或者友元只能访问派生类中包含的基类public以及protected数据，而不能直接访问基类中的数据  </span><br><span class="line">比如下面的例子：  </span><br><span class="line">![](https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;14&#x2F;6cTkCziBjumS59y.png)   </span><br><span class="line">(2)友元没有继承的作用，基类的友元不能访问派生类的数据成员，派生类的友元同样不能访问基类的数据成员  </span><br><span class="line">#### 改变派生类中基类成员的可访问性</span><br><span class="line">可以使用using声明的方式改变派生类中基类成员的可访问性  </span><br><span class="line">例如：</span><br></pre></td></tr></table></figure>
<p>class base<br>{<br>protected:<br>    int n;<br>};<br>class Derived:public base<br>{<br>public:<br>    using Base::n;<br>};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">解读：本来Derived私有继承于基类，对于Derived的用户来讲，n是不可访问的，但是通过这种using方式使得n变为public，可以访问。  </span><br><span class="line">#### struct和class的唯一区别  </span><br><span class="line">1. 数据成员对用户的默认访问权限不同</span><br><span class="line">2. 默认继承方式不同，struct默认public继承，class默认private继承  </span><br><span class="line"></span><br><span class="line">#### 虚析构函数  </span><br><span class="line">基类必须要定义一个虚析构函数，这样在基类引用或者指针销毁时才能保证无论是基类对象还是派生类对象都能够正确销毁  </span><br><span class="line"></span><br><span class="line">定义虚析构函数带来的影响：如果一个类定义了虚析构函数，即使它通过&#x3D;default的形式使用了默认的版本，编译器也不会为这个类生成移动操作。因此当我们移动构造基类对象或者派生类对象时实际调用的是拷贝构造。</span><br><span class="line"></span><br><span class="line">#### 派生类的拷贝构造&#x2F;拷贝赋值&#x2F;移动构造&#x2F;移动赋值&#x2F;析构  </span><br><span class="line">1. 派生类的拷贝构造&#x2F;拷贝赋值&#x2F;移动构造&#x2F;移动赋值需要先显式地调用基类的对应函数再构造派生类特有的数据成员  </span><br><span class="line">2. 析构函数只需要销毁派生类特有的数据成员即可  </span><br><span class="line">3. 派生类使用基类的默认构造函数&#x2F;拷贝构造函数&#x2F;移动构造函数构造基类数据成员时必须在初始化列表使用而不能在函数体中使用  </span><br><span class="line">**注意：只有构造函数才有初始化列表，赋值运算符函数调用基类对应函数直接调用就可以**</span><br></pre></td></tr></table></figure>
<p>class Base {<br>public:<br>    Base(int bMem) :bMem(bMem) {}<br>    Base(const Base&amp;rhs) :bMem(rhs.bMem) {}<br>    Base&amp; operator=(const Base&amp;rhs)<br>    {<br>        bMem = rhs.bMem;<br>        return *this;<br>    }<br>    Base(Base &amp;&amp;rhs) noexcept<br>    {<br>        bMem = rhs.bMem;<br>    }<br>    virtual ~Base() = default;<br>    int bMem;<br>};<br>class Derived :public Base<br>{<br>public:<br>    Derived(int b, int d) :Base(b), dMem(d) {  }//使用基类构造函数构造基类数据成员<br>    Derived(const Derived&amp;rhs) :dMem(rhs.dMem), Base(rhs) {}//使用基类拷贝构造函数构造基类数据成员，且在初始化列表中调用<br>    Derived&amp; operator=(const Derived&amp;rhs)<br>    {<br>        Base::operator=(rhs);//使用基类赋值运算符拷贝基类数据成员，且在函数体中直接调用<br>        dMem = rhs.dMem;<br>        return *this;<br>    }<br>    ~Derived() = default;<br>    Derived(Derived &amp;&amp; rhs) = default;<br>private:int dMem;<br>};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 在容器中同时保存基类与派生类成员的方法  </span><br><span class="line">把容器的数据类型定为基类指针&#x2F;智能指针  </span><br><span class="line">#### 虚拷贝技术  </span><br><span class="line">**应用于基类对象与派生类对象的动态内存分配**</span><br><span class="line">观察一下例子：</span><br></pre></td></tr></table></figure>
<p>void func(const Base&amp;obj)<br>{<br>    …<br>    auto ptr=new Base(obj);<br>    …<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接用new来动态分配对象是错误的，因为obj可能是Base类型也可能是Derived类型。而这种方式因为已经显式地声明了类型为Base会把Derived类型的派生数据部分砍掉  </span><br><span class="line">正确的方法是使用虚拷贝</span><br></pre></td></tr></table></figure>
<p>基类中：<br>virtual Base* clone()const {return new Base(<em>this);}<br>派生类中：<br>Derived</em> clone()const override{return new Derived(*this);}//注意虚函数重写只要求形参列表完全匹配，返回值类型只要是来自基类返回值类型的协变即可</p>
<p>```<br>这样无论是Base类对象BaseObj还是Derived类对象DerivedObj，都只需要.clone()就可以返回一个动态内存分配的指针<br>void func(const Base&amp;obj)<br>{<br>    …<br>    auto ptr=obj.clone();<br>    …<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/12/Primer%20C++Note/" data-id="ck5a9ivm30000a8uzemtu4xg6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/12/hello-world/" class="article-date">
  <time datetime="2020-01-12T00:04:19.874Z" itemprop="datePublished">2020-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/12/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/12/hello-world/" data-id="ck5a9dn7p00003wuz5v8oe7i2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/12/Primer%20C++Note/">Primer C++Note</a>
          </li>
        
          <li>
            <a href="/2020/01/12/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>